// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

// Package les implements the Light Ethereum Subprotocol.
package les

import (
	"errors"
	"sync/atomic"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/contracts/registrar"
	"github.com/ethereum/go-ethereum/contracts/registrar/contract"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/rawdb"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethdb"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/light"
	"github.com/ethereum/go-ethereum/log"
	"github.com/ethereum/go-ethereum/params"
)

// Backend wraps all needed functions for registrar.
type Backend interface {
	SubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription
}

// RegistrarConfig is the configuration parameters of registrar.
type RegistrarConfig struct {
	// ContractAddr the address of checkpoint registrar contract.
	//
	// If not specified, system will use address from the hard code address list
	// according to the genesis hash of the current chain.
	ContractAddr common.Address

	// Signers is the trusted checkpoint signer address list.
	//
	// If not specified, system will use address list from the hard code signers list
	// according to the genesis hash of the current chain.
	Signers []common.Address

	// CheckpointSize is the block frequency for creating a checkpoint.
	CheckpointSize uint64

	// ProcessConfirms is the number of confirmations before a checkpoint is generated.
	ProcessConfirms uint64

	// FreezeThreshold is the number of confirmations before a checkpoint is regarded
	// as stable.
	FreezeThreshold uint64
}

// defaultConfig contains default settings for use on the Ethereum main net or test net.
var defaultConfig = &RegistrarConfig{
	CheckpointSize:  params.CheckpointFrequency,
	ProcessConfirms: params.CheckpointProcessConfirmations,
	FreezeThreshold: params.FreezeThreshold,
}

// checkpointRegistrar is responsible for updating the stable checkpoint
// which generated by local and announced by contract admins in the server
// side and verifying advertised checkpoint during the checkpoint syncing
// in the client side.
type checkpointRegistrar struct {
	config        *RegistrarConfig     // configuration for registrar.
	indexerConfig *light.IndexerConfig // configuration for indexer parameters.

	lightMode bool
	genesis   common.Hash
	chaindb   ethdb.Database
	contract  *registrar.Registrar
	backend   Backend
	exitCh    chan struct{}

	contractAddr common.Address   // address of checkpoint contract.
	signers      []common.Address // a set of trusted checkpoint signers.

	// Indexers
	bloomTrieIndexer *core.ChainIndexer
	chtIndexer       *core.ChainIndexer

	// Atomic fields
	running int32

	// Test Hooks
	SyncDoneHook func() // Function used to notify that light syncing has completed.
}

// newCheckpointRegistrar returns a checkpoint registrar handler.
func newCheckpointRegistrar(chaindb ethdb.Database, backend Backend, config *RegistrarConfig, indexerConfig *light.IndexerConfig, chtIndexer *core.ChainIndexer, bloomTrieIndexer *core.ChainIndexer, genesis common.Hash, lightMode bool, exitCh chan struct{}) *checkpointRegistrar {
	var (
		contractAddr common.Address
		signers      []common.Address
	)
	// Load default contract address and relative signers according to genesis hash
	addr, ok := registrar.RegistrarAddr[genesis]
	if ok {
		contractAddr, signers = addr, registrar.CheckpointSigners[genesis]
	}
	// Load specified contract address and signers.
	if config != nil && config.ContractAddr != (common.Address{}) {
		contractAddr, signers = config.ContractAddr, config.Signers
	}
	if contractAddr == (common.Address{}) || len(signers) == 0 {
		log.Info("Disable checkpoint registrar", "reason", "missing contract address or signers")
		return nil
	}
	log.Info("Setup registrar", "contract", contractAddr, "numsigner", len(signers))
	reg := &checkpointRegistrar{
		config:           config,
		indexerConfig:    indexerConfig,
		genesis:          genesis,
		backend:          backend,
		bloomTrieIndexer: bloomTrieIndexer,
		chtIndexer:       chtIndexer,
		lightMode:        lightMode,
		contractAddr:     contractAddr,
		signers:          signers,
		chaindb:          chaindb,
		exitCh:           exitCh,
	}
	return reg
}

// start binds the registrar contract and start listening to the
// newCheckpointEvent for the server side.
func (reg *checkpointRegistrar) start(backend bind.ContractBackend) {
	contract, err := registrar.NewRegistrar(reg.contractAddr, backend)
	if err != nil {
		log.Info("Bind registrar contract failed", "err", err)
		return
	}
	if !atomic.CompareAndSwapInt32(&reg.running, 0, 1) {
		log.Info("Already bound and listening to registrar contract")
		return
	}
	reg.contract = contract
	if !reg.lightMode {
		go reg.checkpointLoop(reg.recoverCheckpoint())
	}
}

// isRunning returns an indicator whether the registrar is running.
func (reg *checkpointRegistrar) isRunning() bool {
	return atomic.LoadInt32(&reg.running) == 1
}

// checkpointLoop is a standalone goroutine to watch new checkpoint
// events and updates local's stable checkpoint.
func (reg *checkpointRegistrar) checkpointLoop(checkpoint *light.TrustedCheckpoint) (err error) {
	type announce struct {
		hash        common.Hash
		blockNumber uint64
	}

	var (
		eventCh       = make(chan *contract.ContractNewCheckpointEvent)
		headCh        = make(chan core.ChainHeadEvent, SubscribeChainHeadEvent)
		announcements = make(map[uint64]announce)
	)
	eventSub, err := reg.contract.WatchNewCheckpointEvent(eventCh)
	if err != nil {
		return err
	}
	headSub := reg.backend.SubscribeChainHeadEvent(headCh)
	if headSub == nil {
		eventSub.Unsubscribe()
		return errors.New("subscribe head event failed")
	}

	ticker := time.NewTicker(5 * time.Minute)
	defer func() {
		eventSub.Unsubscribe()
		headSub.Unsubscribe()
		ticker.Stop()
	}()

	for {
		select {
		case event := <-eventCh:
			if event == nil {
				// This should never happen.
				log.Info("Ignore empty checkpoint event")
				continue
			}
			// Note several events have same index may be received because of chain reorg and
			// the modification of the latest checkpoint.
			if checkpoint == nil || event.Index.Uint64() > checkpoint.SectionIdx {
				valid, signer := reg.verifySigner(event.CheckpointHash, event.Signature)
				if !valid {
					continue
				}
				log.Info("Receive new checkpoint event", "section", event.Index, "hash", common.Hash(event.CheckpointHash).Hex(),
					"signer", signer.Hex())
				announcements[event.Index.Uint64()] = announce{common.Hash(event.CheckpointHash), event.Raw.BlockNumber}
			} else if event.Index.Uint64() == checkpoint.SectionIdx {
				// Override the stable checkpoint due to reorg.
				local := light.ReadTrustedCheckpoint(reg.chaindb)
				if local.BlockNumber != event.Raw.BlockNumber && local.HashEqual(common.Hash(event.CheckpointHash)) {
					local.BlockNumber = event.Raw.BlockNumber
					light.WriteTrustedCheckpoint(reg.chaindb, local)
				}
				log.Debug("Override stable checkpoint", "section", event.Index, "hash", common.Hash(event.CheckpointHash).Hex(),
					"number", event.Raw.BlockNumber)
			}

		case head := <-headCh:
			number := head.Block.NumberU64()
			if number < reg.config.CheckpointSize+reg.config.FreezeThreshold {
				continue
			}
			sections := (number - reg.config.FreezeThreshold) / reg.config.CheckpointSize
			local := uint64(0)
			if checkpoint != nil {
				local = checkpoint.SectionIdx + 1
			}
			// There is a possibility to update the stable checkpoint.
			if sections > local {
				for index := sections - 1; ; index -= 1 {
					anno, ok := announcements[index]
					if !ok {
						if index == 0 {
							break
						}
						continue
					}
					sectionHead := reg.bloomTrieIndexer.SectionHead(index)
					idxV1 := (index+1)*reg.indexerConfig.PairChtSize/reg.indexerConfig.ChtSize - 1
					c := &light.TrustedCheckpoint{
						BlockNumber: anno.blockNumber,
						SectionIdx:  index,
						SectionHead: sectionHead,
						CHTRoot:     light.GetChtRoot(reg.chaindb, idxV1, sectionHead),
						BloomRoot:   light.GetBloomTrieRoot(reg.chaindb, index, sectionHead),
					}
					if c.HashEqual(common.Hash(anno.hash)) {
						light.WriteTrustedCheckpoint(reg.chaindb, c)
						checkpoint = c
						announcements = make(map[uint64]announce)
						log.Info("Update stable checkpoint", "section", checkpoint.SectionIdx, "hash", checkpoint.Hash().Hex())
						break
					}
				}
			}

		case <-ticker.C:
			// Evict useless announcement every 5 minutes.
			for idx := range announcements {
				if checkpoint != nil && checkpoint.SectionIdx >= idx {
					delete(announcements, idx)
				}
			}
		case <-reg.exitCh:
			// Les server is closed.
			return
		}
	}
}

// recoveryCheckpoint filters checkpoint announcement events and recovers stable checkpoint.
func (reg *checkpointRegistrar) recoverCheckpoint() *light.TrustedCheckpoint {
	var (
		sectionCnt, _, _ = reg.bloomTrieIndexer.Sections()
		stable           = light.ReadTrustedCheckpoint(reg.chaindb)
		headHash         = rawdb.ReadHeadHeaderHash(reg.chaindb)
		headNumber       = rawdb.ReadHeaderNumber(reg.chaindb, headHash)
	)
	// Short circuit if there is no local checkpoint generated.
	if headNumber == nil || sectionCnt == 0 {
		return nil
	}
	start := time.Now()
	unstableIdx := sectionCnt - 1
	for stable == nil || stable.SectionIdx < unstableIdx {
		if (unstableIdx+1)*reg.config.CheckpointSize+reg.config.FreezeThreshold <= *headNumber {
			iter, err := reg.contract.FilterNewCheckpointEvent(*headNumber, unstableIdx, reg.config.CheckpointSize, reg.config.ProcessConfirms)
			if err != nil {
				continue
			}
			idxV1 := (unstableIdx+1)*reg.indexerConfig.PairChtSize/reg.indexerConfig.ChtSize - 1
			for iter.Next() {
				valid, _ := reg.verifySigner(iter.Event.CheckpointHash, iter.Event.Signature)
				if !valid {
					continue
				}
				sectionHead := reg.bloomTrieIndexer.SectionHead(unstableIdx)
				checkpoint := &light.TrustedCheckpoint{
					BlockNumber: iter.Event.Raw.BlockNumber,
					SectionIdx:  unstableIdx,
					SectionHead: sectionHead,
					CHTRoot:     light.GetChtRoot(reg.chaindb, idxV1, sectionHead),
					BloomRoot:   light.GetBloomTrieRoot(reg.chaindb, unstableIdx, sectionHead),
				}
				if checkpoint.HashEqual(common.Hash(iter.Event.CheckpointHash)) {
					light.WriteTrustedCheckpoint(reg.chaindb, checkpoint)
					iter.Close()
					log.Info("Recover stable checkpoint", "index", checkpoint.SectionIdx, "hash", checkpoint.Hash().Hex(), "elapsed", common.PrettyDuration(time.Since(start)))
					return checkpoint
				}
			}
			iter.Close()
		}
		if unstableIdx == 0 {
			break
		}
		unstableIdx -= 1
	}
	if stable == nil {
		log.Info("No stable checkpoint", "elapsed", common.PrettyDuration(time.Since(start)))
	} else {
		log.Info("Recover stable checkpoint", "index", stable.SectionIdx, "hash", stable.Hash().Hex(), "elapsed", common.PrettyDuration(time.Since(start)))
	}
	return stable
}

// latestLocalCheckpoint finds the common stored section index and returns a set of
// post-processed trie roots (CHT and BloomTrie) associated with
// the appropriate section index and head hash as a local checkpoint package.
//
// Note for cht, the section size in LES1 is 4K, so indexer still uses LES/1
// 4k section size for backwards server compatibility. For bloomTrie, the size
// of the section used for indexer is 32K.
func (reg *checkpointRegistrar) latestLocalCheckpoint() (uint64, common.Hash, common.Hash, common.Hash) {
	chtCount, _, _ := reg.chtIndexer.Sections()
	bloomTrieCount, _, _ := reg.bloomTrieIndexer.Sections()
	count := chtCount / (reg.indexerConfig.PairChtSize / reg.indexerConfig.ChtSize)
	// Cap the section index if the two sections are not consistent.
	if count > bloomTrieCount {
		count = bloomTrieCount
	}
	if count == 0 {
		// No checkpoint information can be provided.
		return 0, common.Hash{}, common.Hash{}, common.Hash{}
	}
	sectionHead, chtRoot, bloomTrieRoot := reg.getLocalCheckpoint(count - 1)
	return count - 1, sectionHead, chtRoot, bloomTrieRoot
}

// getLocalCheckpoint returns a set of post-processed trie roots (CHT and BloomTrie)
// associated with the appropriate head hash by specific section index.
//
// The returned checkpoint is only the checkpoint generated by the local indexers,
// not the stable checkpoint registered in the registrar contract.
func (reg *checkpointRegistrar) getLocalCheckpoint(index uint64) (common.Hash, common.Hash, common.Hash) {
	// convert last LES/2 section index back to LES/1 index for chtIndexer.SectionHead
	latest := (index+1)*(reg.indexerConfig.PairChtSize/reg.indexerConfig.ChtSize) - 1

	sectionHead := reg.chtIndexer.SectionHead(latest)
	chtRoot := light.GetChtRoot(reg.chaindb, latest, sectionHead)
	bloomTrieRoot := light.GetBloomTrieRoot(reg.chaindb, index, sectionHead)
	return sectionHead, chtRoot, bloomTrieRoot
}

// stableCheckpoint returns the stable checkpoint which generated by local indexers
// and announced by trusted admins.
func (reg *checkpointRegistrar) stableCheckpoint() *light.TrustedCheckpoint {
	if c := light.ReadTrustedCheckpoint(reg.chaindb); c != nil {
		return c
	}
	if hardcoded, ok := light.TrustedCheckpoints[reg.genesis]; ok {
		return &hardcoded
	}
	return light.EmptyCheckpoint
}

// VerifySigner recovers the signer address according to the signature and
// checks whether it is one of the specified checkpoint signer.
func (reg *checkpointRegistrar) verifySigner(checkpointHash [32]byte, signature []byte) (bool, common.Address) {
	pubkey, err := crypto.Ecrecover(checkpointHash[:], signature)
	if err != nil {
		return false, common.Address{}
	}
	var signer common.Address
	copy(signer[:], crypto.Keccak256(pubkey[1:])[12:])

	for _, s := range reg.signers {
		if s == signer {
			return true, signer
		}
	}
	return false, common.Address{}
}
